"""
LangChain AI Agent for Adaptive Job Application Form Filling

This agent can intelligently fill any job application form by:
1. Analyzing the form structure
2. Understanding field context and meaning
3. Mapping user profile data to appropriate fields
4. Handling multi-step forms and validation
5. Providing real-time feedback to users
"""

import json
import time
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import logging

# LangChain imports
try:
    from langchain.llms import Ollama
    from langchain.prompts import PromptTemplate
    from langchain.chains import LLMChain
    from langchain.agents import Tool, AgentExecutor, create_react_agent
    from langchain.schema import AgentAction, AgentFinish
    from langchain.callbacks.manager import CallbackManagerForToolRun
    from pydantic import BaseModel, Field
    LANGCHAIN_IMPORTS_AVAILABLE = True
except ImportError:
    print("LangChain not installed. Install with: pip install langchain")
    LANGCHAIN_IMPORTS_AVAILABLE = False
    
    # Create comprehensive mock classes to prevent import errors
    class BaseModel:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def dict(self):
            return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}
    
    class Field:
        def __init__(self, description="", **kwargs):
            self.description = description
            
    class Tool:
        def __init__(self, name="", description="", func=None, **kwargs):
            self.name = name
            self.description = description
            self.func = func
            
    class Ollama:
        def __init__(self, model="llama3:latest"):
            self.model = model
            
        def invoke(self, prompt):
            # Simple fallback response
            return '{"is_valid": true, "confidence": 0.5, "reason": "Basic validation only - LangChain not available", "detected_indicators": []}'
    
    class PromptTemplate:
        def __init__(self, input_variables=None, template="", **kwargs):
            self.input_variables = input_variables or []
            self.template = template
    
    class LLMChain:
        def __init__(self, llm=None, prompt=None, **kwargs):
            self.llm = llm
            self.prompt = prompt
        
        def run(self, **kwargs):
            return "Mock response"
    
    class AgentExecutor:
        def __init__(self, **kwargs):
            pass
    
    def create_react_agent(*args, **kwargs):
        return None
    
    class AgentAction:
        pass
    
    class AgentFinish:
        pass
    
    class CallbackManagerForToolRun:
        pass

# Browser automation (Playwright is more modern than Selenium)
try:
    from playwright.async_api import async_playwright, Page, Browser
    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False
    print("Playwright not installed. Install with: pip install playwright")

class FormField(BaseModel):
    """Represents a form field detected by the AI agent"""
    element_id: Optional[str] = Field(description="HTML element ID")
    element_name: Optional[str] = Field(description="HTML element name")
    field_type: str = Field(description="Type of field (text, email, select, etc.)")
    label_text: str = Field(description="Visible label or placeholder text")
    is_required: bool = Field(description="Whether field is required")
    current_value: Optional[str] = Field(description="Current field value")
    suggested_profile_mapping: Optional[str] = Field(description="Which profile field should map to this")

class FormAnalysis(BaseModel):
    """Complete analysis of a job application form"""
    form_title: str = Field(description="Title or heading of the form")
    total_fields: int = Field(description="Total number of form fields")
    required_fields: int = Field(description="Number of required fields")
    form_fields: List[FormField] = Field(description="List of all detected form fields")
    is_multi_step: bool = Field(description="Whether this is a multi-step form")
    next_button_text: Optional[str] = Field(description="Text of next/continue button")
    submit_button_text: Optional[str] = Field(description="Text of submit button")

class LangChainJobApplicationAgent:
    """
    Intelligent AI agent for adaptive job application form filling
    """
    
    def __init__(self, llm_model: str = "llama3"):
        if LANGCHAIN_IMPORTS_AVAILABLE:
            self.llm = Ollama(model=llm_model)
        else:
            # Use our existing Ollama integration when LangChain is not available
            self.llm = self._create_fallback_ollama_client()
            
        self.browser: Optional[Browser] = None
        self.page: Optional[Page] = None
        self.logger = logging.getLogger(__name__)
        
        # Initialize tools for the agent
        self.tools = self._create_agent_tools()
        
        # Create the LangChain agent
        self.agent = self._create_langchain_agent()
        
    def _create_agent_tools(self) -> List[Tool]:
        """Create tools that the AI agent can use"""
        
        tools = [
            Tool(
                name="analyze_page",
                description="Analyze the current page to detect form fields and structure",
                func=self._analyze_page_structure
            ),
            Tool(
                name="fill_field",
                description="Fill a specific form field with appropriate data from user profile",
                func=self._fill_form_field
            ),
            Tool(
                name="click_button",
                description="Click a button (next, continue, submit) on the form",
                func=self._click_button
            ),
            Tool(
                name="handle_dropdown",
                description="Select appropriate option from dropdown/select field",
                func=self._handle_dropdown_selection
            ),
            Tool(
                name="upload_file",
                description="Upload resume or other files to file input fields",
                func=self._upload_file
            ),
            Tool(
                name="check_validation",
                description="Check for validation errors and required fields",
                func=self._check_form_validation
            ),
            Tool(
                name="take_screenshot",
                description="Take screenshot for user feedback and debugging",
                func=self._take_screenshot
            )
        ]
        
        return tools
    
    def _create_langchain_agent(self):
        """Create the main LangChain agent with ReAct pattern"""
        
        # Agent prompt template
        agent_prompt = PromptTemplate(
            input_variables=["tools", "tool_names", "user_profile", "job_url", "agent_scratchpad"],
            template="""
You are an intelligent job application assistant. Your task is to fill out job application forms using the provided user profile data.

Available tools: {tool_names}
Tools: {tools}

User Profile Data:
{user_profile}

Job Application URL: {job_url}

Your approach should be:
1. First analyze the page structure to understand the form
2. Map user profile data to appropriate form fields intelligently
3. Fill fields systematically, handling validation errors
4. Progress through multi-step forms when needed
5. Provide clear feedback about your actions

Think step by step and use the tools available to complete the job application.

{agent_scratchpad}
"""
        )
        
        # Create the agent (this would need proper LangChain agent setup)
        # For now, this is a placeholder structure
        return None
    
    async def start_browser(self, headless: bool = False):
        """Start browser session - always visible for user feedback"""
        if not PLAYWRIGHT_AVAILABLE:
            self.logger.warning("âš ï¸  Playwright not available - cannot start browser automation")
            raise ImportError("Playwright is required for browser automation but dependencies are missing")
            
        try:
            self.playwright = await async_playwright().start()
            
            # Try to connect to existing browser first (for tab-based automation)
            try:
                # Try to connect to an existing browser instance
                self.browser = await self.playwright.chromium.connect_over_cdp("http://localhost:9222")
                self.logger.info("ðŸ”— Connected to existing browser - will open new tab")
                
                # Create new page in existing browser (new tab)
                context = self.browser.contexts[0] if self.browser.contexts else await self.browser.new_context()
                self.page = await context.new_page()
                
            except Exception as connect_error:
                self.logger.info(f"No existing browser found, launching new one: {connect_error}")
                
                # Launch new browser if connection fails
                self.browser = await self.playwright.chromium.launch(
                    headless=False,  # Always visible
                    args=[
                        '--no-sandbox', 
                        '--disable-dev-shm-usage',
                        '--start-maximized',  # Start maximized for better visibility
                        '--remote-debugging-port=9222'  # Enable remote debugging for future connections
                    ]
                )
                
                context = await self.browser.new_context(
                    viewport={'width': 1920, 'height': 1080}  # Large viewport
                )
                self.page = await context.new_page()
            
            self.logger.info("ðŸŒ Browser automation ready - you can see the form filling in action!")
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to start Playwright browser: {e}")
            raise ImportError(f"Playwright browser startup failed: {e}. System dependencies may be missing.")
        
    async def close_browser(self):
        """Close browser session (only close tab if connected to existing browser)"""
        try:
            if self.page:
                # Close only the current page/tab
                await self.page.close()
                self.logger.info("ðŸ—™ Closed automation tab")
            
            # Only close entire browser if we launched it ourselves
            if self.browser and hasattr(self.browser, '_connection'):
                # If this is a connected browser, don't close it completely
                self.logger.info("ðŸ”— Left existing browser open")
            elif self.browser:
                # If we launched the browser, close it
                await self.browser.close()
                self.logger.info("ðŸ—™ Closed automation browser")
                
            if hasattr(self, 'playwright'):
                await self.playwright.stop()
        except Exception as e:
            self.logger.error(f"Error during browser cleanup: {e}")
    
    def get_application_url(self, job_url: str) -> str:
        """
        Convert job URLs to direct application URLs (especially for Lever)
        """
        # Handle Lever URLs - add /apply to go directly to application form
        if "jobs.lever.co" in job_url and not job_url.endswith("/apply"):
            application_url = job_url.rstrip("/") + "/apply"
            self.logger.info(f"ðŸ”— Lever URL transformed: {job_url} â†’ {application_url}")
            return application_url
        
        # Handle other ATS platforms that might need URL modifications
        # Greenhouse URLs are typically direct to application form
        # Workday URLs vary by company implementation
        
        return job_url

    async def fill_job_application(
        self, 
        job_url: str, 
        user_profile: Dict[str, Any],
        resume_file_path: Optional[str] = None,
        user_callback: Optional[callable] = None
    ) -> Dict[str, Any]:
        """
        Main method to fill a job application using AI agent
        """
        
        try:
            # Transform URL to direct application URL if needed
            application_url = self.get_application_url(job_url)
            
            self.logger.info(f"ðŸš€ Starting job application automation...")
            self.logger.info(f"ðŸ“‹ Job URL: {application_url}")
            
            # Navigate to the job application with better timeout handling
            self.logger.info("ðŸ“¥ Navigating to job application...")
            try:
                await self.page.goto(application_url, timeout=60000)  # 60 seconds timeout
                self.logger.info("â³ Loading application form...")
                
                # Wait for page to be ready with multiple strategies
                try:
                    await self.page.wait_for_load_state('networkidle', timeout=30000)
                    self.logger.info("âœ… Page loaded successfully")
                except Exception as load_error:
                    self.logger.warning(f"âš ï¸  NetworkIdle timeout, trying domcontentloaded: {load_error}")
                    await self.page.wait_for_load_state('domcontentloaded', timeout=15000)
                    # Give additional time for dynamic content
                    await self.page.wait_for_timeout(3000)
                    self.logger.info("âœ… Page content loaded")
                    
            except Exception as nav_error:
                self.logger.error(f"âŒ Navigation failed: {nav_error}")
                # Take screenshot for debugging
                try:
                    await self.page.screenshot(path="/tmp/navigation_error.png")
                    self.logger.info("ðŸ“¸ Screenshot saved to /tmp/navigation_error.png")
                except:
                    pass
                raise Exception(f"Failed to navigate to job application: {nav_error}")
            
            # Validate that this is actually a valid job posting
            job_validation = await self._validate_job_posting()
            if not job_validation["is_valid"]:
                self.logger.warning(f"âš ï¸  {job_validation['reason']}")
                return {
                    "success": False,
                    "error": "job_no_longer_available",
                    "reason": job_validation["reason"],
                    "user_message": job_validation["user_message"],
                    "timestamp": datetime.now().isoformat()
                }
            
            # Start the intelligent form filling process
            result = await self._intelligent_form_filling(user_profile, resume_file_path, user_callback)
            
            return {
                "success": True,
                "result": result,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"Error filling job application: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
    
    async def _intelligent_form_filling(
        self, 
        user_profile: Dict[str, Any], 
        resume_file_path: Optional[str],
        user_callback: Optional[callable]
    ) -> Dict[str, Any]:
        """
        Intelligent form filling using AI reasoning
        """
        
        # Step 1: Analyze the page structure
        form_analysis = await self._analyze_page_structure()
        
        # Step 2: Create field mapping strategy
        field_mapping = await self._create_intelligent_field_mapping(form_analysis, user_profile)
        
        # Step 3: Execute form filling
        filling_result = await self._execute_form_filling(field_mapping, resume_file_path, user_callback)
        
        return {
            "form_analysis": form_analysis,
            "field_mapping": field_mapping,
            "filling_result": filling_result
        }
    
    async def _analyze_page_structure(self) -> Dict[str, Any]:
        """Analyze current page to detect form structure"""
        
        # Get all form elements
        form_elements = await self.page.evaluate("""
            () => {
                const forms = document.querySelectorAll('form');
                const fields = [];
                
                forms.forEach(form => {
                    const inputs = form.querySelectorAll('input, select, textarea');
                    inputs.forEach(input => {
                        const label = input.labels?.[0]?.textContent || 
                                    input.placeholder || 
                                    input.getAttribute('aria-label') || 
                                    input.name || '';
                        
                        fields.push({
                            type: input.type || input.tagName.toLowerCase(),
                            name: input.name || '',
                            id: input.id || '',
                            label: label.trim(),
                            required: input.required,
                            value: input.value || ''
                        });
                    });
                });
                
                return fields;
            }
        """)
        
        # Use AI to analyze and categorize fields
        analysis_prompt = f"""
        Analyze these form fields and categorize them for job application context:
        
        Form Fields: {json.dumps(form_elements, indent=2)}
        
        For each field, determine:
        1. What type of information it's asking for
        2. Which user profile field should map to it
        3. How important/required it is
        4. Any special handling needed
        
        Return JSON format:
        {{
            "categorized_fields": [
                {{
                    "field_id": "field_name_or_id",
                    "field_type": "text|email|phone|select|textarea|file",
                    "likely_purpose": "first_name|last_name|email|phone|resume|cover_letter|address|experience",
                    "confidence": 0.9,
                    "mapping_suggestion": "personal_information.full_name",
                    "required": true
                }}
            ],
            "form_complexity": "simple|moderate|complex",
            "estimated_fill_time": 120
        }}
        """
        
        try:
            # Use LLM to analyze the form structure
            if hasattr(self.llm, 'invoke'):
                # Try synchronous invoke first
                try:
                    ai_analysis = self.llm.invoke(analysis_prompt)
                except Exception as sync_error:
                    # If sync fails, try async
                    self.logger.warning(f"Sync LLM call failed, trying async: {sync_error}")
                    ai_analysis = await self._safe_llm_call(analysis_prompt)
            else:
                ai_analysis = await self._safe_llm_call(analysis_prompt)
            
            # Parse AI response
            try:
                analysis_data = json.loads(ai_analysis)
            except json.JSONDecodeError:
                # Fallback to basic analysis
                analysis_data = self._basic_field_analysis(form_elements)
            
            return {
                "fields": form_elements,
                "ai_analysis": analysis_data,
                "total_fields": len(form_elements),
                "analysis_timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"AI analysis failed: {e}")
            return {
                "fields": form_elements,
                "ai_analysis": self._basic_field_analysis(form_elements),
                "total_fields": len(form_elements),
                "analysis_timestamp": datetime.now().isoformat()
            }
    
    async def _create_intelligent_field_mapping(
        self, 
        form_analysis: Dict[str, Any], 
        user_profile: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create intelligent mapping between user profile and form fields"""
        
        # Use AI to create smart field mapping
        mapping_prompt = f"""
        Create intelligent mapping between user profile and form fields:
        
        User Profile:
        {json.dumps(user_profile, indent=2)}
        
        Form Analysis:
        {json.dumps(form_analysis.get('ai_analysis', {}), indent=2)}
        
        Create a precise mapping strategy. Return JSON:
        {{
            "field_mappings": {{
                "field_name_or_id": {{
                    "profile_path": "personal_information.full_name",
                    "value": "John Doe",
                    "transform": "none|split_name|format_phone|format_date",
                    "fallback_value": "",
                    "confidence": 0.95
                }}
            }},
            "filling_order": ["field1", "field2", "field3"],
            "special_handling": [
                {{
                    "field": "resume_upload",
                    "type": "file_upload",
                    "instructions": "Upload resume file"
                }}
            ]
        }}
        """
        
        try:
            # Use LLM to create the mapping
            if hasattr(self.llm, 'invoke'):
                try:
                    ai_mapping = self.llm.invoke(mapping_prompt)
                except Exception as sync_error:
                    self.logger.warning(f"Sync LLM mapping call failed: {sync_error}")
                    ai_mapping = await self._safe_llm_call(mapping_prompt)
            else:
                ai_mapping = await self._safe_llm_call(mapping_prompt)
            
            try:
                mapping_data = json.loads(ai_mapping)
            except json.JSONDecodeError:
                # Fallback to basic mapping
                mapping_data = self._basic_field_mapping(form_analysis, user_profile)
            
            return mapping_data
            
        except Exception as e:
            self.logger.error(f"AI mapping failed: {e}")
            return self._basic_field_mapping(form_analysis, user_profile)
    
    async def _execute_form_filling(
        self, 
        field_mapping: Dict[str, Any], 
        resume_file_path: Optional[str],
        user_callback: Optional[callable]
    ) -> Dict[str, Any]:
        """Execute the actual form filling based on AI analysis"""
        
        filled_fields = []
        errors = []
        
        try:
            # Execute form filling based on AI mapping
            field_mappings = field_mapping.get("field_mappings", {})
            filling_order = field_mapping.get("filling_order", [])
            special_handling = field_mapping.get("special_handling", [])
            
            # Fill fields in order
            for field_id in filling_order:
                if field_id in field_mappings:
                    mapping = field_mappings[field_id]
                    
                    try:
                        # Fill the field
                        success = await self._fill_field_with_mapping(field_id, mapping, resume_file_path)
                        
                        if success:
                            filled_fields.append({
                                "field_id": field_id,
                                "value": mapping.get("value", ""),
                                "status": "success"
                            })
                        else:
                            errors.append({
                                "field_id": field_id,
                                "error": "Failed to fill field",
                                "severity": "medium"
                            })
                            
                    except Exception as e:
                        errors.append({
                            "field_id": field_id,
                            "error": str(e),
                            "severity": "high"
                        })
                        
            # Handle special cases (file uploads, etc.)
            for special in special_handling:
                try:
                    await self._handle_special_field(special, resume_file_path)
                    filled_fields.append({
                        "field_id": special.get("field", ""),
                        "type": special.get("type", ""),
                        "status": "success"
                    })
                except Exception as e:
                    errors.append({
                        "field_id": special.get("field", ""),
                        "error": str(e),
                        "severity": "high"
                    })
            
            # Provide user callback if available
            if user_callback:
                await user_callback({
                    "status": "filling_complete",
                    "filled_fields": len(filled_fields),
                    "errors": len(errors)
                })
            
            # Wait for user confirmation before submitting
            await self._wait_for_user_confirmation(filled_fields, errors)
            
            return {
                "filled_fields": filled_fields,
                "errors": errors,
                "status": "awaiting_user_confirmation",
                "next_action": "user_must_review_and_submit"
            }
            
        except Exception as e:
            self.logger.error(f"Form filling execution failed: {e}")
            return {
                "filled_fields": filled_fields,
                "errors": [{"error": str(e), "severity": "critical"}],
                "status": "failed"
            }
    
    # Helper methods for AI analysis
    def _basic_field_analysis(self, form_elements: List[Dict]) -> Dict[str, Any]:
        """Fallback field analysis when AI fails"""
        categorized = []
        
        for element in form_elements:
            field_type = element.get('type', '').lower()
            label = element.get('label', '').lower()
            name = element.get('name', '').lower()
            
            # Basic field categorization with improved pattern matching
            if 'first' in label or 'first' in name or 'fname' in name:
                purpose = 'first_name'
                mapping = 'personal_information.basic_information.first_name'
            elif 'last' in label or 'last' in name or 'lname' in name:
                purpose = 'last_name'
                mapping = 'personal_information.basic_information.last_name'
            elif 'full' in label or 'name' in label and 'first' not in label and 'last' not in label:
                purpose = 'full_name'
                mapping = 'personal_information.basic_information.full_name'
            elif field_type == 'email' or 'email' in label or 'email' in name:
                purpose = 'email'
                mapping = 'personal_information.contact_information.email'
            elif 'phone' in label or 'phone' in name or 'tel' in name:
                purpose = 'phone'
                mapping = 'personal_information.contact_information.telephone'
            elif 'address' in label or 'address' in name:
                purpose = 'address'
                mapping = 'personal_information.address.address'
            elif 'city' in label or 'city' in name:
                purpose = 'city'
                mapping = 'personal_information.address.city'
            elif 'state' in label or 'state' in name:
                purpose = 'state'
                mapping = 'personal_information.address.state'
            elif 'zip' in label or 'postal' in label or 'zip' in name:
                purpose = 'zip_code'
                mapping = 'personal_information.address.zip_code'
            elif field_type == 'file' or 'resume' in label or 'cv' in label:
                purpose = 'resume'
                mapping = 'file_upload'
            else:
                purpose = 'unknown'
                mapping = 'unknown'
            
            categorized.append({
                "field_id": element.get('name') or element.get('id', ''),
                "field_type": field_type,
                "likely_purpose": purpose,
                "confidence": 0.7,
                "mapping_suggestion": mapping,
                "required": element.get('required', False)
            })
        
        return {
            "categorized_fields": categorized,
            "form_complexity": "moderate",
            "estimated_fill_time": 60
        }
    
    def _basic_field_mapping(self, form_analysis: Dict, user_profile: Dict) -> Dict[str, Any]:
        """Fallback field mapping when AI fails"""
        mappings = {}
        order = []
        special = []
        
        personal_info = user_profile.get('personal_information', {})
        basic_info = personal_info.get('basic_information', {})
        contact_info = personal_info.get('contact_information', {})
        address_info = personal_info.get('address', {})
        
        # Use the correct profile structure from CLAUDE.md
        full_name = f"{basic_info.get('first_name', '')} {basic_info.get('last_name', '')}".strip()
        email = contact_info.get('email', '')
        phone = contact_info.get('telephone', '')
        address = address_info.get('address', '')
        city = address_info.get('city', '')
        state = address_info.get('state', '')
        zip_code = address_info.get('zip_code', '')
        
        for field in form_analysis.get('ai_analysis', {}).get('categorized_fields', []):
            field_id = field.get('field_id', '')
            purpose = field.get('likely_purpose', '')
            
            if purpose == 'first_name':
                first_name = basic_info.get('first_name', '')
                mappings[field_id] = {
                    "profile_path": "personal_information.basic_information.first_name",
                    "value": first_name,
                    "transform": "none",
                    "confidence": 0.9
                }
            elif purpose == 'last_name':
                last_name = basic_info.get('last_name', '')
                mappings[field_id] = {
                    "profile_path": "personal_information.basic_information.last_name",
                    "value": last_name,
                    "transform": "none",
                    "confidence": 0.9
                }
            elif purpose == 'full_name':
                mappings[field_id] = {
                    "profile_path": "personal_information.basic_information.full_name",
                    "value": full_name,
                    "transform": "none",
                    "confidence": 0.9
                }
            elif purpose == 'email':
                mappings[field_id] = {
                    "profile_path": "personal_information.contact_information.email",
                    "value": email,
                    "transform": "none",
                    "confidence": 0.95
                }
            elif purpose == 'phone':
                mappings[field_id] = {
                    "profile_path": "personal_information.contact_information.telephone",
                    "value": phone,
                    "transform": "format_phone",
                    "confidence": 0.9
                }
            elif purpose == 'address':
                mappings[field_id] = {
                    "profile_path": "personal_information.address.address",
                    "value": address,
                    "transform": "none",
                    "confidence": 0.8
                }
            elif purpose == 'city':
                mappings[field_id] = {
                    "profile_path": "personal_information.address.city",
                    "value": city,
                    "transform": "none",
                    "confidence": 0.8
                }
            elif purpose == 'state':
                mappings[field_id] = {
                    "profile_path": "personal_information.address.state",
                    "value": state,
                    "transform": "none",
                    "confidence": 0.8
                }
            elif purpose == 'zip_code':
                mappings[field_id] = {
                    "profile_path": "personal_information.address.zip_code",
                    "value": zip_code,
                    "transform": "none",
                    "confidence": 0.8
                }
            elif purpose == 'resume':
                special.append({
                    "field": field_id,
                    "type": "file_upload",
                    "instructions": "Upload resume file"
                })
            
            if field_id and field_id not in order:
                order.append(field_id)
        
        return {
            "field_mappings": mappings,
            "filling_order": order,
            "special_handling": special
        }
    
    async def _fill_field_with_mapping(self, field_id: str, mapping: Dict, resume_path: Optional[str] = None) -> bool:
        """Fill a single field using the mapping data with visual feedback"""
        try:
            value = mapping.get('value', '')
            transform = mapping.get('transform', 'none')
            
            # Apply transformations
            if transform == 'format_phone':
                value = self._format_phone_number(value)
            elif transform == 'format_date':
                value = self._format_date(value)
            
            # Find and fill the field with multiple selector strategies
            selectors = [
                f'[name="{field_id}"]',
                f'#{field_id}',
                f'[id*="{field_id}"]',
                f'[placeholder*="{field_id}"]'
            ]
            
            element = None
            for selector in selectors:
                try:
                    element = await self.page.wait_for_selector(selector, timeout=2000)
                    if element:
                        break
                except:
                    continue
            
            if element:
                # Visual feedback - highlight field before filling (fix Playwright API)
                try:
                    await element.evaluate("el => el.style.border = '3px solid red'")  # Highlight with border
                except:
                    pass  # Skip highlighting if it fails
                
                # Clear field first
                await element.clear()
                
                # Type with delay for visual effect
                await element.type(value, delay=50)  # 50ms delay between characters
                
                # Remove highlight after filling
                try:
                    await element.evaluate("el => el.style.border = ''")
                except:
                    pass
                
                self.logger.info(f"âœï¸  Filled '{field_id}' with: {value}")
                
                # Small pause for user to see the action
                await self.page.wait_for_timeout(500)
                
                return True
            else:
                self.logger.warning(f"âš ï¸  Could not find field: {field_id}")
                return False
            
        except Exception as e:
            self.logger.error(f"âŒ Error filling field {field_id}: {e}")
            return False
    
    async def _handle_special_field(self, special: Dict, resume_path: Optional[str] = None) -> bool:
        """Handle special fields like file uploads with visual feedback"""
        try:
            field_type = special.get('type', '')
            field_id = special.get('field', '')
            
            if field_type == 'file_upload' and resume_path:
                # Try multiple selectors for file upload
                selectors = [
                    f'[name="{field_id}"]',
                    f'#{field_id}',
                    'input[type="file"]',
                    '[accept*="pdf"]',
                    '[accept*="doc"]'
                ]
                
                file_input = None
                for selector in selectors:
                    try:
                        file_input = await self.page.wait_for_selector(selector, timeout=2000)
                        if file_input:
                            break
                    except:
                        continue
                
                if file_input:
                    # Visual feedback - highlight upload field
                    try:
                        await file_input.evaluate("el => el.style.border = '3px solid blue'")  # Highlight with border
                    except:
                        pass  # Skip highlighting if it fails
                    
                    self.logger.info(f"ðŸ“„ Uploading resume: {resume_path}")
                    
                    # Upload file
                    await file_input.set_input_files(resume_path)
                    
                    # Remove highlight after upload
                    try:
                        await file_input.evaluate("el => el.style.border = ''")
                    except:
                        pass
                    
                    # Wait for upload to process
                    await self.page.wait_for_timeout(1000)
                    
                    self.logger.info("âœ… Resume uploaded successfully!")
                    return True
                else:
                    self.logger.warning("âš ï¸  Could not find file upload field")
            
            return False
            
        except Exception as e:
            self.logger.error(f"âŒ Error handling special field: {e}")
            return False
    
    def _format_phone_number(self, phone: str) -> str:
        """Format phone number for forms"""
        if not phone:
            return ''
        
        # Remove all non-digits
        digits = ''.join(filter(str.isdigit, phone))
        
        # Format as (XXX) XXX-XXXX if 10 digits
        if len(digits) == 10:
            return f'({digits[:3]}) {digits[3:6]}-{digits[6:]}'
        
        return phone
    
    def _format_date(self, date_str: str) -> str:
        """Format date for forms"""
        # Basic date formatting - could be enhanced
        return date_str
    
    # Tool implementation methods
    def _fill_form_field(self, field_info: str) -> str:
        """Tool function to fill a specific form field"""
        # Implementation for filling individual fields
        return f"Filled field: {field_info}"
    
    def _click_button(self, button_info: str) -> str:
        """Tool function to click buttons"""
        # Implementation for clicking buttons
        return f"Clicked button: {button_info}"
    
    def _handle_dropdown_selection(self, dropdown_info: str) -> str:
        """Tool function to handle dropdown selections"""
        # Implementation for dropdown handling
        return f"Selected dropdown option: {dropdown_info}"
    
    def _upload_file(self, file_info: str) -> str:
        """Tool function to upload files"""
        # Implementation for file uploads
        return f"Uploaded file: {file_info}"
    
    def _check_form_validation(self) -> str:
        """Tool function to check form validation"""
        # Implementation for validation checking
        return "Validation check completed"
    
    def _take_screenshot(self, purpose: str) -> str:
        """Tool function to take screenshots"""
        # Implementation for screenshots
        return f"Screenshot taken for: {purpose}"
    
    async def _wait_for_user_confirmation(self, filled_fields: List, errors: List):
        """Wait for user to review and confirm submission"""
        
        # Find submit button
        submit_button = await self._find_submit_button()
        
        if submit_button:
            # Highlight submit button
            await submit_button.highlight()
            
            # Show summary to user
            summary_message = self._generate_completion_summary(filled_fields, errors)
            self.logger.info(summary_message)
            
            # Visual indicator - scroll to submit button
            await submit_button.scroll_into_view_if_needed()
            
            self.logger.info("â¸ï¸  AUTOMATION PAUSED - Review the form and click submit when ready")
            self.logger.info("ðŸ” Please review all filled information carefully")
            self.logger.info("âœ… Click the highlighted SUBMIT button when you're satisfied")
            self.logger.info("âŒ Or close the browser tab to cancel")
            
        else:
            self.logger.warning("âš ï¸  Could not locate submit button - please submit manually")
    
    async def _find_submit_button(self):
        """Find the submit button using multiple strategies"""
        submit_selectors = [
            'button[type="submit"]',
            'input[type="submit"]',
            'button:has-text("Submit")',
            'button:has-text("Apply")',
            'button:has-text("Send")',
            'button:has-text("Continue")',
            '[data-qa*="submit"]',
            '[data-testid*="submit"]',
            '.submit-button',
            '#submit',
            '[value*="Submit"]'
        ]
        
        for selector in submit_selectors:
            try:
                button = await self.page.wait_for_selector(selector, timeout=1000)
                if button:
                    return button
            except:
                continue
        
        return None
    
    def _generate_completion_summary(self, filled_fields: List, errors: List) -> str:
        """Generate a summary of the automation completion"""
        
        total_fields = len(filled_fields)
        error_count = len(errors)
        
        summary = f"""
ðŸŽ‰ FORM FILLING COMPLETED!
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ… Successfully filled: {total_fields} fields
{'âŒ Errors encountered: ' + str(error_count) if error_count > 0 else 'âœ¨ No errors - perfect!'}

ðŸ“‹ FILLED FIELDS:"""
        
        for field in filled_fields[:5]:  # Show first 5 fields
            field_name = field.get('field_id', 'Unknown')
            field_value = field.get('value', '')[:30] + '...' if len(field.get('value', '')) > 30 else field.get('value', '')
            summary += f"\n   â€¢ {field_name}: {field_value}"
        
        if len(filled_fields) > 5:
            summary += f"\n   â€¢ ... and {len(filled_fields) - 5} more fields"
        
        if error_count > 0:
            summary += f"\n\nâš ï¸  ERRORS ({error_count}):"
            for error in errors[:3]:  # Show first 3 errors
                error_field = error.get('field_id', 'Unknown')
                error_msg = error.get('error', 'Unknown error')
                summary += f"\n   â€¢ {error_field}: {error_msg}"
        
        summary += "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        return summary
    
    async def _safe_llm_call(self, prompt: str) -> str:
        """Safe LLM call that handles async/sync issues"""
        try:
            if hasattr(self.llm, 'orchestrator'):
                # Use direct orchestrator call
                return await self.llm.orchestrator._call_ollama(prompt)
            else:
                # Fallback to basic response
                return '{"error": "LLM not available", "fallback": true}'
        except Exception as e:
            self.logger.error(f"Safe LLM call failed: {e}")
            return '{"error": "LLM call failed", "fallback": true}'

    def _create_fallback_ollama_client(self):
        """Create a fallback Ollama client when LangChain is not available"""
        import sys
        import os
        backend_path = os.path.join(os.path.dirname(__file__), '..', '..', 'backend')
        sys.path.append(backend_path)
        
        try:
            from agent_orchestrator import AgentOrchestrator
            orchestrator = AgentOrchestrator()
            
            class FallbackOllamaClient:
                def __init__(self, orchestrator):
                    self.orchestrator = orchestrator
                    
                async def invoke(self, prompt):
                    return await self.orchestrator._call_ollama(prompt)
                    
                def invoke(self, prompt):
                    # For sync calls, skip to avoid event loop issues
                    return '{"error": "Sync call disabled to avoid event loop conflicts", "fallback": true}'
            
            return FallbackOllamaClient(orchestrator)
            
        except Exception as e:
            self.logger.error(f"Failed to create fallback Ollama client: {e}")
            # Return the mock Ollama if all else fails
            return Ollama()
    
    async def _validate_job_posting(self) -> Dict[str, Any]:
        """
        Use AI to validate if the current page contains a valid job posting
        """
        try:
            # Get page content for AI analysis
            page_title = await self.page.title()
            page_text = await self.page.inner_text('body')
            
            # Limit text for AI analysis (first 2000 characters)
            analysis_text = page_text[:2000] if page_text else ""
            
            # Create validation prompt
            validation_prompt = f"""
Analyze this webpage to determine if it contains a valid job application form or job posting.

Page Title: {page_title}
Page Content: {analysis_text}

Look for indicators of:
1. VALID JOB POSTING:
   - Job title and description
   - Application form fields (name, email, resume upload)
   - "Apply now" or similar buttons
   - Company information
   - Job requirements or qualifications

2. INVALID/EXPIRED JOB:
   - "Job no longer available" messages
   - "Position has been filled" messages
   - "404" or "Page not found" errors
   - Redirect to company homepage
   - Generic company pages without job details
   - "Sorry" or "expired" messages

Respond with JSON only:
{{
    "is_valid": true/false,
    "confidence": 0.0-1.0,
    "reason": "brief explanation",
    "detected_indicators": ["list", "of", "key", "indicators"]
}}
"""
            
            try:
                # Use AI to analyze the page
                ai_response = self.llm.invoke(validation_prompt)
                
                # Parse AI response
                try:
                    # Extract JSON from response
                    start = ai_response.find('{')
                    end = ai_response.rfind('}')
                    if start != -1 and end != -1:
                        json_str = ai_response[start:end+1]
                        validation_result = json.loads(json_str)
                    else:
                        # Fallback to basic validation
                        validation_result = self._basic_job_validation(page_title, analysis_text)
                        
                except json.JSONDecodeError:
                    # Fallback to basic validation
                    validation_result = self._basic_job_validation(page_title, analysis_text)
                
                # Add user-friendly message
                if validation_result.get("is_valid", True):
                    validation_result["user_message"] = "âœ… Valid job posting found - proceeding with application"
                else:
                    reason = validation_result.get("reason", "Unknown issue")
                    validation_result["user_message"] = f"âŒ Job no longer available: {reason}"
                
                return validation_result
                
            except Exception as e:
                self.logger.error(f"AI validation failed: {e}")
                # Fallback to basic validation
                return self._basic_job_validation(page_title, analysis_text)
                
        except Exception as e:
            self.logger.error(f"Job validation failed: {e}")
            # If validation fails, assume job is valid to avoid false negatives
            return {
                "is_valid": True,
                "confidence": 0.5,
                "reason": "Validation failed, proceeding cautiously",
                "user_message": "âš ï¸ Could not verify job status - proceeding with application",
                "detected_indicators": []
            }
    
    def _basic_job_validation(self, page_title: str, page_text: str) -> Dict[str, Any]:
        """
        Basic job validation without AI - fallback method
        """
        page_title_lower = page_title.lower() if page_title else ""
        page_text_lower = page_text.lower() if page_text else ""
        
        # Check for invalid job indicators
        invalid_indicators = [
            "job no longer available",
            "position has been filled", 
            "this job is no longer active",
            "posting has expired",
            "position closed",
            "no longer accepting applications",
            "404",
            "page not found",
            "sorry, this job",
            "job has been removed"
        ]
        
        detected_invalid = []
        for indicator in invalid_indicators:
            if indicator in page_title_lower or indicator in page_text_lower:
                detected_invalid.append(indicator)
        
        # Check for valid job indicators
        valid_indicators = [
            "apply now",
            "submit application", 
            "upload resume",
            "first name",
            "email address",
            "cover letter",
            "job description",
            "qualifications",
            "requirements"
        ]
        
        detected_valid = []
        for indicator in valid_indicators:
            if indicator in page_title_lower or indicator in page_text_lower:
                detected_valid.append(indicator)
        
        # Determine validity
        if detected_invalid:
            return {
                "is_valid": False,
                "confidence": 0.8,
                "reason": f"Found invalid job indicators: {', '.join(detected_invalid[:2])}",
                "detected_indicators": detected_invalid
            }
        elif len(detected_valid) >= 2:
            return {
                "is_valid": True,
                "confidence": 0.7,
                "reason": f"Found valid application indicators: {', '.join(detected_valid[:3])}",
                "detected_indicators": detected_valid
            }
        else:
            # Uncertain - lean towards valid to avoid false negatives
            return {
                "is_valid": True,
                "confidence": 0.4,
                "reason": "Uncertain job status - proceeding cautiously",
                "detected_indicators": detected_valid + detected_invalid
            }

# Example usage and testing
async def test_langchain_agent():
    """Test the LangChain agent with a sample job application"""
    
    agent = LangChainJobApplicationAgent()
    
    # Sample user profile
    user_profile = {
        "personal_information": {
            "full_name": "John Doe",
            "email": "john.doe@example.com",
            "phone": "(555) 123-4567"
        },
        "work_experience": [
            {
                "title": "Software Engineer",
                "company": "TechCorp",
                "start_date": "2020-01",
                "end_date": None
            }
        ]
    }
    
    try:
        await agent.start_browser(headless=False)  # Visual mode for testing
        
        result = await agent.fill_job_application(
            job_url="https://example.com/apply",
            user_profile=user_profile,
            resume_file_path="/path/to/resume.pdf"
        )
        
        print("Application result:", json.dumps(result, indent=2))
        
    finally:
        await agent.close_browser()

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_langchain_agent())